if ARCH_PXA

menu "Intel PXA2xx Implementations"

config ARCH_LUBBOCK
	bool "Intel DBPXA250 Development Platform"
	select PXA25x
	select SA1111

config MACH_LOGICPD_PXA270
	bool "LogicPD PXA270 Card Engine Development Platform"
	select PXA27x

config MACH_MAINSTONE
	bool "Intel HCDDBBVA0 Development Platform"
	select PXA27x

config ARCH_PXA_IDP
	bool "Accelent Xscale IDP"
	select PXA25x

source "arch/arm/mach-pxa/eseries/Kconfig"
source "arch/arm/mach-pxa/asus620/Kconfig"
source "arch/arm/mach-pxa/asus716/Kconfig"
source "arch/arm/mach-pxa/asus730/Kconfig"
source "arch/arm/mach-pxa/h1900/Kconfig"
source "arch/arm/mach-pxa/h2200/Kconfig"
source "arch/arm/mach-pxa/h3900/Kconfig"
source "arch/arm/mach-pxa/h4000/Kconfig"
source "arch/arm/mach-pxa/hx4700/Kconfig"
source "arch/arm/mach-pxa/hx2750/Kconfig"
source "arch/arm/mach-pxa/h5400/Kconfig"
source "arch/arm/mach-pxa/htchimalaya/Kconfig"
source "arch/arm/mach-pxa/htcuniversal/Kconfig"
source "arch/arm/mach-pxa/htcalpine/Kconfig"
source "arch/arm/mach-pxa/magician/Kconfig"
source "arch/arm/mach-pxa/htcapache/Kconfig"
source "arch/arm/mach-pxa/htcblueangel/Kconfig"
source "arch/arm/mach-pxa/htcsable/Kconfig"
source "arch/arm/mach-pxa/htcathena/Kconfig"
source "arch/arm/mach-pxa/aximx3/Kconfig"
source "arch/arm/mach-pxa/aximx5/Kconfig"
source "arch/arm/mach-pxa/aximx30/Kconfig"
source "arch/arm/mach-pxa/aximx50/Kconfig"
source "arch/arm/mach-pxa/rover/Kconfig"
source "arch/arm/mach-pxa/palmld/Kconfig"
source "arch/arm/mach-pxa/palmt3/Kconfig"
source "arch/arm/mach-pxa/plat-recon/Kconfig"
source "arch/arm/mach-pxa/mioa701/Kconfig"

config MACH_GHI270HG
	bool "Grayhill Duramax HG"

config MACH_GHI270
	bool "Grayhill Duramax H"
	select PXA27x
	select MACH_GHI270HG

config MACH_LOOXC550
	bool "FSC LOOX C550"
	select PXA27x

config PXA_SHARPSL
	bool "SHARP Zaurus SL-5600, SL-C7xx and SL-Cxx00 Models"
	select SHARP_SCOOP
	select SHARP_PARAM
	help
	  Say Y here if you intend to run this kernel on a
	  Sharp Zaurus SL-5600 (Poodle), SL-C700 (Corgi),
	  SL-C750 (Shepherd), SL-C760 (Husky), SL-C1000 (Akita),
	  SL-C3000 (Spitz), SL-C3100 (Borzoi) or SL-C6000x (Tosa)
	  handheld computer.

config MACH_TRIZEPS4
	bool "Keith und Koep Trizeps4 DIMM-Module"
	select PXA27x

if PXA_SHARPSL

choice
	prompt "Select target Sharp Zaurus device range"

config PXA_SHARPSL_25x
	bool "Sharp PXA25x models (SL-5600, SL-C7xx and SL-C6000x)"
	select PXA25x

config PXA_SHARPSL_27x
	bool "Sharp PXA270 models (SL-Cxx00)"
	select PXA27x

endchoice

endif

if MACH_TRIZEPS4

choice
	prompt "Select base board for Trizeps 4 module"

config MACH_TRIZEPS4_CONXS
	bool "ConXS Eval Board"

config MACH_TRIZEPS4_ANY
	bool "another Board"

endchoice

endif

endmenu

config MACH_POODLE
	bool "Enable Sharp SL-5600 (Poodle) Support"
	depends on PXA_SHARPSL_25x
	select SHARP_LOCOMO
	select PXA_SSP

config MACH_CORGI
	bool "Enable Sharp SL-C700 (Corgi) Support"
	depends on PXA_SHARPSL_25x
	select PXA_SHARP_C7xx

config MACH_SHEPHERD
	bool "Enable Sharp SL-C750 (Shepherd) Support"
	depends on PXA_SHARPSL_25x
	select PXA_SHARP_C7xx

config MACH_HUSKY
	bool "Enable Sharp SL-C760 (Husky) Support"
	depends on PXA_SHARPSL_25x
	select PXA_SHARP_C7xx

config MACH_AKITA
	bool "Enable Sharp SL-1000 (Akita) Support"
	depends on PXA_SHARPSL_27x
	select PXA_SHARP_Cxx00
	select MACH_SPITZ
	select I2C
	select I2C_PXA

config MACH_SPITZ
	bool "Enable Sharp Zaurus SL-3000 (Spitz) Support"
	depends on PXA_SHARPSL_27x
	select PXA_SHARP_Cxx00

config MACH_BORZOI
	bool "Enable Sharp Zaurus SL-3100 (Borzoi) Support"
	depends on PXA_SHARPSL_27x
	select PXA_SHARP_Cxx00

config MACH_TOSA
	bool "Enable Sharp SL-6000x (Tosa) Support"
	depends on PXA_SHARPSL_25x

config PXA25x
	bool
	help
	  Select code specific to PXA21x/25x/26x variants

config PXA26x
	bool
	help
	  Select code specific to PXA26x variants

config PXA27x
	bool
	help
	  Select code specific to PXA27x variants

config PXA_SHARP_C7xx
	bool
	select PXA_SSP
	select SHARPSL_PM
	help
	  Enable support for all Sharp C7xx models

config PXA_SHARP_Cxx00
	bool
	select PXA_SSP
	select SHARPSL_PM
	help
	  Enable common support for Sharp Cxx00 models

config PXA_SSP
	tristate
	help
	  Enable support for PXA2xx SSP ports

config PXA_SUSPEND_SAVE_EXTRA_REGS
	bool
	help
	  Save additional registers on the stack during suspend
	  to work around certain bootloaders overwriting them
	  during resume.

config PXA27x_VOLTAGE
	tristate "Support PXA27x CPU Core Voltage Change Sequencer"
	depends PXA27x && CPU_FREQ_PXA

config PXA27x_VOLTAGE_MAX158xx
	tristate "MAX158xx PMIC"
	depends on PXA27x_VOLTAGE

config GPIO
 bool "GPIO pin support for PXA27x"
 default y if ARM || PPC
 default n
 help
 Enabling this option adds support for PXA GPIO pins. Most
 System-on-Chip processors have this kind of pins mostly shared
 with some kind of internal hardware. Remaining pins may be used
 for any purposes (input/output/interrupt etc). To do so, enable
 this feature and provide some kernel parameters to define what
 pins are available. To define one or more GPIO pin give a:
 gpio.mapping=<pin#>:(in|(out:(hi|lo)))[.<pin#>:(in|(out:(hi|lo)))]
 Where <pin#> is any GPIO pin number your SoC supports, out or in
 is the data direction and hi or lo is one of the possible
 levels an output pin can have.
 For example. You have three GPIO: pin 8, 63 and 113. Pin 8 is a
 simple key input, pin 63 an output to control a motor. It needs
 a high level first to stop the motor while booting. Pin 113 is
 also an output pin, but needs low level while booting. To do so,
 give this kernel parameter:
 gpio.mapping=8:in.63:out:hi.113:out:lo
 With "cat /proc/gpio" you will get:
 GPIO POLICY DIRECTION OWNER
 8: user space input kernel
 63: user space output kernel
 113: user space output kernel
 To set pin 63 to low (to start the motor) do a:
 $ echo 0 > /sys/class/gpio/gpio63/level
 Or to stop the motor again:
 $ echo 1 > /sys/class/gpio/gpio63/level
 To get the level of the key (pin 8) do:
 $ cat /sys/class/gpio/gpio8/level
 The result will be 1 or 0.

 To add new GPIO pins at runtime (lets say pin 88 should be an input)
 you can do a:
 $ echo 88:in > /sys/class/gpio/map_gpio
 The same with a new GPIO pin 95, it should be an output and at high level:
 $ echo 95:out:hi > /sys/class/gpio/map_gpio

 After that "cat /proc/gpio" will show you:
 GPIO POLICY DIRECTION OWNER
 8: user space input kernel
 63: user space output kernel
 113: user space output kernel
 88: user space input kernel
 95: user space output kernel

 Note: You can add more than one new GPIO pin in one step. The period is the
 delimiter between each pin definition. To add the pins 88 and 95 in the
 example above in one step do a:
 $ echo 88:in.95:out:hi > /sys/class/gpio/map_gpio

 To remove any of these GPIOs use (in this example GPIO pin 95):
 $ echo 95 > /sys/class/gpio/unmap_gpio

 If unsure, say N.



endif

